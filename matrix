#!/bin/bash

# Name: Molly Johnson
# ONID: johnsmol
# CS 344 Fall 2018
# Due: 10/8/18
# Assignment 1
# All information used to implement this script is adapted
# from the OSU CS 344 Fall 2018 lectures and assignment hints
# unless otherwise specifically indicated.

dims(){
# NAME
# dims - figure out dimensions of a given matrix
# SYNOPSOS
# calculate and print num of rows, a space, and then the num of columns of the matrix
# DESCRIPTION
# This is the dims function. This function will take a valid file as an argument or
# accept input from stdin. If the file is not readable or too many/few arguments
# are given, it will print an error message to stderr and return a value of 1. If
# the file or stdin input is valid, it will print the number of rows, a space, and
# then the number of columns to stdout and returns 0 (0 is returned automatically).

# use the tempInputDims variable to hold path to file with passed in matrix (doesn't
# matter if passed in from stdin or froma file). $$ added to end of temp file in order
# to prevent any duplicate names being used again mistakenly
tempInputDims="tempdims$$"
if [ "$#" = "1" ]
then
	cat > "$tempInputDims"
elif [ "$#" = "2" ]
then
	tempInputDims=$2
fi

# use wc (word count) with the -l option to count the number of lines (i.e. rows) in the file.
# to prevent a newline from being output after this to stdout, use tr (transform) with the -d
# option and the newline character, as this will remove the newline character that would normally
# be sent to stdout after the line count is printed via wc -l.
# using wc -l to count lines (i.e. rows) in a file adapted from:
# https://stackoverflow.com/questions/3137094/how-to-count-lines-in-a-document and
# https://superuser.com/questions/249307/avoid-printing-line-breaks-in-shell-script
cat $tempInputDims | wc -l | tr -d '\n'
echo -n " "

# head normally reads in first 10 lines of text from a file ($2). -1 added to make head
# only read in the first row. All tabs are then transformed into newlines, and the number
# of newlines counted (wc is word count, and the -l option makes it only give the line count). Hence
# the number of new lines counted + the original first line will equal the number of columns from the original file.
# adapted from: https://stackoverflow.com/questions/5761212/count-number-of-columns-in-bash/5761234
head -1 $tempInputDims | tr '\t' '\n' | wc -l

# check to see if the tempfile exists using -a. if it does exist, remove it. otherwise do nothing.
# This file checking is adapted from: 
# https://askubuntu.com/questions/558977/checking-for-a-file-and-whether-it-is-readable-and-writable/558990 
if [[ -a tempdims$$ ]]
then
	rm -f tempdims$$
fi
}

transpose(){
# NAME
# transpose - reflect matrix elements along the diagonal 
# SYNOPSOS
# transpose matrix elements so that an MxN matrix becomes an NxM matrix, with the diagonal 
# elements remaining unchanged.
# DESCRIPTION
# 

# use the tempInputTrans variable to hold path to file with passed in matrix (doesn't
# matter if passed in from stdin or froma file). $$ added to end of temp file in order
# to prevent any duplicate names being used again mistakenly
tempInputTrans="temptrans$$"
if [ "$#" = "1" ]
then
	cat > "$tempInputTrans"
elif [ "$#" = "2" ]
then
	tempInputTrans=$2
fi

# store the number of columns in the cols variable.
# head normally reads in first 10 lines of text from a file ($2). -1 added to make head
# only read in the first row. All tabs are then transformed into newlines, and the number
# of newlines counted (wc is word count, and the -l option makes it only give the line count). Hence
# the number of new lines counted + the original first line will equal the number of columns from the original file.
# adapted from: https://stackoverflow.com/questions/5761212/count-number-of-columns-in-bash/5761234
# storing command output in a variable adapted from:
# https://unix.stackexchange.com/questions/122014/setting-output-of-a-command-to-a-variable 
cols="$(head -1 $tempInputTrans | tr '\t' '\n' | wc -l)"

# alternate for loop format adapted from:
# https://www.cyberciti.biz/faq/bash-for-loop/
# using cut to take a column from the file and paste each column as a new line adapted from:
# https://www.thelinuxrain.com/articles/transposing-rows-and-columns-3-methods
# details about the cut and command and paste commands adapted from:
# https://www.mkssoftware.com/docs/man1/cut.1.asp and https://www.mkssoftware.com/docs/man1/paste.1.asp
# -fn where n is an integer tells cut to cut in field delimiter mode, cutting each column where n is the column number
# -s tells paste to concatenate all lines from each input file together on the single output line, in this
# case to put the values for each column from the file into a new row, hence transposing the elements in the file
for (( i=1; i <= cols; i++ ))
do
	cut -f"$i" $tempInputTrans | paste -s
done

# check to see if the tempfile exists using -a. if it does exist, remove it. otherwise do nothing.
# This file checking is adapted from: 
# https://askubuntu.com/questions/558977/checking-for-a-file-and-whether-it-is-readable-and-writable/558990 
if [[ -a temptrans$$ ]]
then
	rm -f temptrans$$
fi
}

mean(){
# NAME
# 
# SYNOPSOS
# 
# DESCRIPTION
# 

# use the tempInputTrans variable to hold path to file with passed in matrix (doesn't
# matter if passed in from stdin or froma file). $$ added to end of temp file in order
# to prevent any duplicate names being used again mistakenly
tempInputMean="tempmean$$"
if [ "$#" = "1" ]
then
	cat > "$tempInputMean"
elif [ "$#" = "2" ]
then
	tempInputMean=$2
fi

# store the number of columns in the cols variable.
# head normally reads in first 10 lines of text from a file ($2). -1 added to make head
# only read in the first row. All tabs are then transformed into newlines, and the number
# of newlines counted (wc is word count, and the -l option makes it only give the line count). Hence
# the number of new lines counted + the original first line will equal the number of columns from the original file.
# adapted from: https://stackoverflow.com/questions/5761212/count-number-of-columns-in-bash/5761234
# storing command output in a variable adapted from:
# https://unix.stackexchange.com/questions/122014/setting-output-of-a-command-to-a-variable 
columns="$(head -1 $tempInputMean | tr '\t' '\n' | wc -l)"

# alternate for loop format adapted from:
# https://www.cyberciti.biz/faq/bash-for-loop/
# using cut to take a column from the file and paste each column as a new line adapted from:
# https://www.thelinuxrain.com/articles/transposing-rows-and-columns-3-methods
# details about the cut and command and paste commands adapted from:
# https://www.mkssoftware.com/docs/man1/cut.1.asp and https://www.mkssoftware.com/docs/man1/paste.1.asp
# -fn where n is an integer tells cut to cut in field delimiter mode, cutting each column where n is the column number
# -s tells paste to concatenate all lines from each input file together on the single output line, in this
# case to put the values for each column from the file into a new row, hence transposing the elements in the file
# temp file created for new transposed matrix prior to summation
tempRowFile="temprow$$"
for (( h=1; h <= columns; h++ ))
do
	cut -f"$h" $tempInputMean | paste -s >> $tempRowFile
done

#
whileCount=1
tempFileRows="$(cat $tempRowFile | wc -l | tr -d '\n')"
origFileRows="$(cat $tempInputMean | wc -l | tr -d '\n')"

# -a -r -s -w used to check that the tempRowFile is valid. -a checks that the file exists,
# -r checks that the file is readable, -s checks that the file isn't empty, and -w checks
# that the file is writable. Adapted from:
# https://askubuntu.com/questions/558977/checking-for-a-file-and-whether-it-is-readable-and-writable
# Method for summing a row of numbers adapted from:
# https://stackoverflow.com/questions/33006845/how-to-sum-a-row-of-numbers-from-text-file-bash-shell-scripting
if [[ -a temprow$$ && -r temprow$$ && -s temprow$$ && -w temprow$$ ]] 
then
	#
	while read sumLine
	do
		sum=0
		for num in $sumLine
		do
			(( sum = sum + num ))
		done

		mean=$(( ($sum + ($origFileRows/2)*( ($sum>0)*2-1 )) / $origFileRows ))

		if [ $whileCount -lt  $tempFileRows ]
		then
			echo -n -e "$mean\t"
		else
			echo "$mean"
		fi

		(( whileCount = whileCount + 1 ))
	done < $tempRowFile
else
	echo "error: file not valid" 1>&2
	exit 1
fi

# check to see if the tempfile exists using -a. if it does exist, remove it. otherwise do nothing.
# This file checking is adapted from: 
# https://askubuntu.com/questions/558977/checking-for-a-file-and-whether-it-is-readable-and-writable/558990 
if [[ -a tempmean$$ ]]
then
	rm -f tempmean$$
fi

# check to see if the tempfile exists using -a. if it does exist, remove it. otherwise do nothing.
# This file checking is adapted from: 
# https://askubuntu.com/questions/558977/checking-for-a-file-and-whether-it-is-readable-and-writable/558990 
if [[ -a temprow$$ ]]
then
	rm -f temprow$$
fi
}

add(){
# NAME
# 
# SYNOPSOS
# 
# DESCRIPTION
# 

leftAddInput="leftaddin$$"
rightAddInput="righdaddin$$"
leftAddInput=$1
rightAddInput=$2

leftColsAdd="$(head -1 $leftAddInput | tr '\t' '\n' | wc -l)"
leftRowsAdd="$(cat $leftAddInput | wc -l | tr -d '\n')"

rightColsAdd="$(head -1 $rightAddInput | tr '\t' '\n' | wc -l)"
rightRowsAdd="$(cat $rightAddInput | wc -l | tr -d '\n')"

if [ $leftColsAdd -ne  $rightColsAdd ] || [ $leftRowsAdd -ne $rightRowsAdd ]
then
	echo "error: mismatched matrices entered" 1>&2
	exit 1
fi

#
#addWhileCount=1
forLoopCount=1
tempAddFile="tempadd$$"
while read leftMatrixLine <&3 && read rightMatrixLine <&4
do
	# https://www.cyberciti.biz/faq/bash-for-loop/
	for num in $leftMatrixLine $rightMatrixLine
	do
		#echo "for loop count is: $forLoopCount"
		#echo  "num is: $num"

		if [ $forLoopCount -lt $leftColsAdd ]
		then
			echo -n -e "$num\t" >> $tempAddFile
		elif [ $forLoopCount -eq $leftColsAdd ]
		then
			echo "$num" >> $tempAddFile
			forLoopCount=0
		fi
		(( forLoopCount = forLoopCount + 1 ))
	done
	#echo "while loop count is: $addWhileCount"
	#(( addWhileCount = addWhileCount + 1 ))
done 3<"$leftAddInput" 4<"$rightAddInput"

tempAddCols="$(head -1 $tempAddFile | tr '\t' '\n' | wc -l)"
tempAddCut="tempaddcut$$"
if [[ -a tempadd$$ && -r tempadd$$ && -s tempadd$$ && -w tempadd$$ ]]  
then
	for (( k=1; k <= $tempAddCols ; k++ ))
	do
		cut -f"$k" $tempAddFile | paste -s >> $tempAddCut
	done
else
	echo "error: file not valid" 1>&2
fi

#
if [[ -a leftaddin$$ ]]
then
	rm -f leftaddin$$
fi

#
if [[ -a rightaddin$$ ]]
then
	rm -f rightaddin$$
fi

#
#if [[ -a tempadd$$ ]]
#then
#	rm -f tempadd$$
#fi

#
#if [[ -a tempaddcut$$ ]]
#then
#	rm -f tempaddcut$$
#fi

}

multiply(){
# NAME
# 
# SYNOPSOS
# 
# DESCRIPTION
# 

leftMultInput="leftmultin$$"
rightMultInput="righdmultin$$"
leftMultInput=$1
rightMultInput=$2

leftColsMult="$(head -1 $leftMultInput | tr '\t' '\n' | wc -l)"
leftRowsMult="$(cat $leftMultInput | wc -l | tr -d '\n')"

rightColsMult="$(head -1 $rightMultInput | tr '\t' '\n' | wc -l)"
rightRowsMult="$(cat $rightMultInput | wc -l | tr -d '\n')"

if [ $leftColsMult -ne  $rightColsMult ] || [ $leftRowsMult -ne $rightRowsMult ]
then
	echo "error: mismatched matrices entered" 1>&2
	exit 1
fi

#
if [[ -a leftmultin$$ ]]
then
	rm -f leftmultin$$
fi

#
if [[ -a rightmultin$$ ]]
then
	rm -f rightmultin$$
fi
}

# check for correct number of arguments (1 or 2 for dims, transpose, and mean since they can also take stdin, and 3 for
# add and multiply, since they must take in 2 files and can't use stdin). If there's an incorrect number of arguments,
# or if a file or files passed in is either unreadable or nonexistent, send error message to stderr and return 1 
# (a non-zero number), otherwise call the appropriate function and return 0 automatically. Note: -s means to check if 
# the file exists and is non-empty,  and -r checks that the file is readable. This file checking is adapted from: 
# https://askubuntu.com/questions/558977/checking-for-a-file-and-whether-it-is-readable-and-writable/558990
if [ "$#" = "1" ]
then
	if [ "$1" = "dims" ] || [ "$1" = "transpose" ] || [ "$1" = "mean" ]     
	then
		$1 "${@:1}"
	else
		echo "error: invalid number of arguments" 1>&2
		exit 1
	fi
elif [ "$#" = "2" ]
then
	if [ "$1" = "dims" ] || [ "$1" = "transpose" ] || [ "$1" = "mean" ]     
	then
		if [[ -s $2 && -r $2 ]]
		then
			$1 "${@:1}"
		else
			echo "error: file does not exist or is not readable" 1>&2
			exit 1
		fi
	else
		echo "error: invalid number of arguments" 1>&2
		exit 1
	fi
elif [ "$#" = "3" ]
then
	if [ "$1" = "add" ] || [ "$1" = "multiply" ]  
	then
		if [[ -s $2 && -r $2 ]] && [[ -s $3 && -r $3 ]] 
		then
			$1 "${@:2}"
		else
			echo "error: file does not exist or is not readable" 1>&2
			exit 1
		fi
	else
		echo "error: invalid number of arguments" 1>&2
		exit 1
	fi
else
	echo "error: invalid number of arguments" 1>&2
	exit 1
fi
